{"paperId": "6c8c4503e3f50848d35deaf080ae4086dd4f60c1", "publicationVenue": {"id": "fcbcaf18-8ab1-43e1-a973-604bbc7e344e", "name": "Proceedings of the VLDB Endowment", "type": "journal", "alternate_names": ["Proceedings of The Vldb Endowment", "Proc VLDB Endow", "Proc Vldb Endow"], "issn": "2150-8097", "url": "http://dl.acm.org/toc.cfm?id=J1174", "alternate_urls": ["http://portal.acm.org/toc.cfm?CFID=21632689&CFTOKEN=99329904&WantType=Affiliated%20Organizations&coll=ACM&dl=ACM&id=J1174&idx=J1174&part=affil&title=VLDB%20Endowment&type=periodical"]}, "title": "Containerized Execution of UDFs: An Experimental Evaluation", "abstract": "User-defined functions (UDFs) have long been used as the de facto way to extend the capabilities of data management systems. However, they are restricted to the specificities of each DBMS, and recent demands for advanced analytics have increased the need for complex UDFs that may require execution of arbitrary computation written in any programming language, management of library dependencies, portability across environments and engines, and resource isolation. These requirements go beyond what traditional UDFs were designed for, and have given rise to containerized UDFs that enable encapsulation and portability. However, this approach is nascent and can result in significant performance penalties and usability issues. In this paper, we present the first study that spans all stages of containerized UDFs' life cycle, performance bottlenecks in their execution, and extensibility to support different engines.\n Our experiments show that the performance of containerized UDF execution can be greatly affected by system design choices and that there are many trade-offs to consider. For example, regarding the method of communication with the containerized UDF, we show that binary-based implementations minimize overheads and are more than 2.4x faster than widely used text-based ones. Adopting a newer general-purpose communication method such as Arrow Flight can improve performance dramatically, causing a minimal ~10% slowdown compared to non-containerized UDFs. Additionally, containerized UDF start times vary wildly due to program size and complexity, from .07s to 7s in our experiments. Our insights can help DBMS developers make appropriate choices based on individual use cases when designing their systems.", "venue": "Proceedings of the VLDB Endowment", "year": 2022, "fieldsOfStudy": ["Computer Science"], "publicationTypes": ["JournalArticle"], "publicationDate": "2022-07-01", "journal": {"name": "Proc. VLDB Endow.", "pages": "3158-3171", "volume": "15"}, "authors": [{"authorId": "35064289", "name": "Karla Saur"}, {"authorId": "2183983556", "name": "Tara Mirmira"}, {"authorId": "2687553", "name": "Konstantinos Karanasos"}, {"authorId": "1401945543", "name": "Jes\u00fas Camacho-Rodr\u00edguez"}], "citations": [{"paperId": "ac08fa76038762f89a0f6c39ea38655422926408", "title": "Towards Building Autonomous Data Services on Azure"}, {"paperId": "3fb4813a08ecbbf4ceb31f722713f4bc8366e709", "title": "User-Defined Functions in Modern Data Engines"}, {"paperId": "a3f6a87457967c41f6c4ed3d10261cded7005b53", "title": "BabelMR: A Polyglot Framework for Serverless MapReduce"}, {"paperId": "6a2d2ba14596a4ec88d559b1cb0c22d625d8ea15", "title": "The Need for Tabular Representation Learning: An Industry Perspective"}]}
