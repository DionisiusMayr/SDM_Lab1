{"paperId": "c41ea4266d1eca7e49eaecb4dca7d70d0720092d", "publicationVenue": {"id": "0f1e902e-a969-4a5d-b316-f66ac2bb560c", "name": "International Workshop on Data Management on New Hardware", "type": "conference", "alternate_names": ["Int Workshop Data Manag New Hardw", "Data Manag New Hardw", "DaMoN", "Data Management on New Hardware"], "url": "http://www.wikicfp.com/cfp/program?id=640"}, "title": "Reducing Bloom Filter CPU Overhead in LSM-Trees on Modern Storage Devices", "abstract": "Bloom filters (BFs) accelerate point lookups in Log-Structured Merge (LSM) trees by reducing unnecessary storage accesses to levels that do not contain the desired key. BFs are particularly beneficial when there is a significant performance difference between querying a BF (hashing and accessing memory) and accessing data (on secondary storage). This gap, however, is decreasing as modern storage devices (SSDs and NVMs) have increasingly lower latency, to the point that the cost of accessing data can be comparable to that of filter probing and hashing, especially for large key sizes that exhibit high hashing cost. In an LSM-tree, BFs are employed when querying each level of the tree, thus, exacerbating the CPU cost as the data size - and thus, the tree height - grows. To address the increasing CPU cost of BFs in LSM-trees, we propose to re-use hash calculations aggressively within and across BFs, as well as between different levels, and we show both analytically and experimentally that we can maintain a close-to-ideal false positive rate while significantly reducing the runtime. The reduced CPU cost for queries using the proposed hash sharing leads to 10% higher lookup performance in an LSM-tree with 22GB of data (5 levels) stored in a state-of-the-art PCIe SSD. The benefit further increases for faster underlying storage. Specifically, we show that for faster NVM devices, hash sharing leads to performance gains up to 40%.", "venue": "International Workshop on Data Management on New Hardware", "year": 2021, "fieldsOfStudy": ["Computer Science"], "publicationTypes": ["Book", "JournalArticle"], "publicationDate": "2021-06-20", "journal": {"name": "Proceedings of the 17th International Workshop on Data Management on New Hardware"}, "authors": [{"authorId": "2140564220", "name": "Zichen Zhu"}, {"authorId": "3009412", "name": "J. Mun"}, {"authorId": "2106382791", "name": "Aneesh Raman"}, {"authorId": "1840402", "name": "Manos Athanassoulis"}], "citations": [{"paperId": "d81a1943b424f205a10f23b78035643bf04dafc9", "title": "Design and Performance Analysis of Modern Computational Storage Devices: A Systematic Review"}, {"paperId": "17bd21a328514fa005b57687dfcfa135edbbf00b", "title": "Practical Dynamic Extension for Sampling Indexes"}, {"paperId": "eb11ed9b8208d3f8fe6e5fc9e5ede4c4ec7ac2d4", "title": "Learning to Optimize LSM-trees: Towards A Reinforcement Learning based Key-Value Store for Dynamic Workloads"}, {"paperId": "88e48943c3a0b53ff0b96a9f5384630d483e7ee2", "title": "Autumn: A Scalable Read Optimized LSM-tree based Key-Value Stores with Fast Point and Range Read Speed"}, {"paperId": "49527bc5a3bb8a097bf84e15825f654497b73206", "title": "The LSM Design Space and its Read Optimizations"}, {"paperId": "5a1572937fae1561e0fa08227fb3107c3cfd990c", "title": "Indexing for Near-Sorted Data"}, {"paperId": "ea3786077ebf4e1be168ac079e170429cc78a938", "title": "Spooky: Granulating LSM-Tree Compactions Correctly"}, {"paperId": "a312b4f5d864bf160a99d8a7945ec19d3a63bdce", "title": "Dissecting, Designing, and Optimizing LSM-based Data Stores"}, {"paperId": "ae728adf50ea299e480a6f7c28925baebb0f995d", "title": "Entropy-Learned Hashing: Constant Time Hashing with Controllable Uniformity"}, {"paperId": "a00fb89878de2677acf951b8a43c14c69030ba5e", "title": "OSM-tree: A Sortedness-Aware Index"}, {"paperId": "c06f37a404227338966ead4b7dd7a5726ba73ed9", "title": "SHaMBa: Reducing Bloom Filter Overhead in LSM Trees"}, {"paperId": "f61a31e2ac8e3de2415321ad63af70a6a8af1fa6", "title": "LSM-Trees Under (Memory) Pressure"}, {"paperId": "c3627014957788e029a73a276dfba820e4a0864f", "title": "Entropy-Learned Hashing 10x Faster Hashing with Controllable Uniformity"}]}
