{"paperId": "5d647f9147dd0412cc45a36e40f8562e46988c24", "publicationVenue": {"id": "deedf64a-dd5c-4b33-b345-ff83bfb93d71", "name": "International Symposium on Computer Architecture", "type": "conference", "alternate_names": ["Int Symp Comput Archit", "ISCA"], "url": "http://www.cs.wisc.edu/~arch/www/"}, "title": "Taming the Zoo: The Unified GraphIt Compiler Framework for Novel Architectures", "abstract": "We live in a new Cambrian Explosion of hardware devices. The end of conventional processor scaling has driven research and industry practice to explore a new generation of approaches. The old DNA of architecture design, including vectors, threads, shared or private memories, coherence or message passing, dataflow or von Neumann execution, are hybridized together in new and exciting ways. Each new architecture exposes a unique hardware-level API. Performance and energy efficiency are critically dependent on how well programs can use these APIs. One approach is to implement custom libraries for each new hardware architecture and application domain. A more scalable approach is to utilize a portable compiler infrastructure tailored to the application domain that makes it easy to generate efficient code for a diverse set of architectures with minimal porting effort.We propose the Unified GraphIt Compiler framework (UGC), which does exactly this for graph applications. UGC achieves portability with reasonable effort by decoupling the architecture-independent algorithm from the architecture-specific schedules and backends. We introduce a new domain-specific intermediate representation, GraphIR, that is key to this decoupling. GraphIR encodes high-level algorithm and optimization information needed for hardware-specific code generation, making it easy to develop different backends (GraphVMs) for diverse architectures, including CPUs, GPUs, and next-generation hardware such as Swarm and the HammerBlade manycore. We also build scheduling language extensions that make it easy to expose optimization decisions like load balancing strategies, blocking for locality, and other data structure choices. We evaluate UGC on five algorithms and 10 input graphs on these 4 distinct architectures and show that UGC enables implementing optimizations that can provide up to 53\u00d7 speedup over programmer-generated straightforward implementations.", "venue": "International Symposium on Computer Architecture", "year": 2021, "fieldsOfStudy": ["Computer Science"], "publicationTypes": ["JournalArticle", "Book"], "publicationDate": "2021-06-01", "journal": {"name": "2021 ACM/IEEE 48th Annual International Symposium on Computer Architecture (ISCA)", "pages": "429-442"}, "authors": [{"authorId": "8871992", "name": "Ajay Brahmakshatriya"}, {"authorId": "2076741644", "name": "Emily Furst"}, {"authorId": "17790173", "name": "Victor A. Ying"}, {"authorId": "2110559765", "name": "Claire Hsu"}, {"authorId": "40372102", "name": "Changwan Hong"}, {"authorId": "47206861", "name": "Max Ruttenberg"}, {"authorId": "11860259", "name": "Yunming Zhang"}, {"authorId": "2007674042", "name": "Dai Cheol Jung"}, {"authorId": "145816323", "name": "D. Richmond"}, {"authorId": "38303344", "name": "M. Taylor"}, {"authorId": "2045944", "name": "Julian Shun"}, {"authorId": "1723213", "name": "M. Oskin"}, {"authorId": "144342279", "name": "Daniel S\u00e1nchez"}, {"authorId": "2134745139", "name": "S. Amarasinghe"}], "citations": [{"paperId": "d28d7a6c4fa5570cd58e65707f9af5cd88e0f221", "title": "Beyond Static Parallel Loops: Supporting Dynamic Task Parallelism on Manycore Architectures with Software-Managed Scratchpad Memories"}, {"paperId": "10dcd5df28171e53adbe35124aea8329fa194a9d", "title": "MeshTaichi"}, {"paperId": "96600df677402f6d832084ffdc250770935fff9e", "title": "A Multi-target, Multi-paradigm DSL Compiler for Algorithmic Graph Processing"}, {"paperId": "8957c8fedc926f697efd1fa28886da5b564e9afa", "title": "Compiling for Vector Extensions With Stream-Based Specialization"}, {"paperId": "fe8493809c30549c4c319ef71fb35cafe5b27167", "title": "PriMax: maximizing DSL application performance with selective primitive acceleration"}, {"paperId": "cbd2e9ec6e9857661751c1728f923422f80e37d2", "title": "A Tensor Processing Framework for CPU-Manycore Heterogeneous Systems"}, {"paperId": "63b809349666fa571782b08364b68acbb1df0c2d", "title": "GraphIt to CUDA Compiler in 2021 LOC: A Case for High-Performance DSL Implementation via Staging with BuilDSL"}, {"paperId": "15e8ea5fc76485cadb04cdde21b1b52b038609ee", "title": "SpZip: Architectural Support for Effective Data Compression In Irregular Applications"}]}
