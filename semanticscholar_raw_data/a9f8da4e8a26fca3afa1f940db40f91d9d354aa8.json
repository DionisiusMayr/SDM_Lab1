{"paperId": "a9f8da4e8a26fca3afa1f940db40f91d9d354aa8", "publicationVenue": {"id": "1901e811-ee72-4b20-8f7e-de08cd395a10", "name": "arXiv.org", "alternate_names": ["ArXiv"], "issn": "2331-8422", "url": "https://arxiv.org"}, "title": "An In-Memory Architecture for High-Performance Long-Read Pre-Alignment Filtering", "abstract": "With the recent move towards sequencing of accurate long reads, finding solutions that support efficient analysis of these reads becomes more necessary. The long execution time required for sequence alignment of long reads negatively affects genomic studies relying on sequence alignment. Although pre-alignment filtering as an extra step before alignment was recently introduced to mitigate sequence alignment for short reads, these filters do not work as efficiently for long reads. Moreover, even with efficient pre-alignment filters, the overall end-to-end (i.e., filtering + original alignment) execution time of alignment for long reads remains high, while the filtering step is now a major portion of the end-to-end execution time. Our paper makes three contributions. First, it identifies data movement of sequences between memory units and computing units as the main source of inefficiency for pre-alignment filters of long reads. This is because although filters reject many of these long sequencing pairs before they get to the alignment stage, they still require a huge cost regarding time and energy consumption for the large data transferred between memory and processor. Second, this paper introduces an adaptation of a short-read pre-alignment filtering algorithm suitable for long reads. We call this LongGeneGuardian. Finally, it presents Filter-Fuse as an architecture that supports LongGeneGuardian inside the memory. FilterFuse exploits the Computation-In-Memory computing paradigm, eliminating the cost of data movement in LongGeneGuardian. Our evaluations show that FilterFuse improves the execution time of filtering by 120.47x for long reads compared to State-of-the-Art (SoTA) filter, SneakySnake. FilterFuse also improves the end-to-end execution time of sequence alignment by up to 49.14x and 5207.63x compared to SneakySnake with SoTA aligner and only SoTA aligner, respectively.", "venue": "arXiv.org", "year": 2023, "fieldsOfStudy": ["Computer Science", "Biology"], "publicationTypes": ["JournalArticle"], "publicationDate": "2023-10-24", "journal": {"name": "ArXiv", "volume": "abs/2310.15634"}, "authors": [{"authorId": "51017214", "name": "Taha Shahroodi"}, {"authorId": "2253772957", "name": "Michael Miao"}, {"authorId": "2160629076", "name": "Joel Lindegger"}, {"authorId": "2171100110", "name": "Stephan Wong"}, {"authorId": "2065984781", "name": "O. Mutlu"}, {"authorId": "2253779185", "name": "Said Hamdioui"}], "citations": [{"paperId": "ec6d1d7cd109320c8432bb8dee1c11f380502364", "title": "PANDA: Processing in Magnetic Random-Access Memory- Accelerated de Bruijn Graph-Based DNA Assembly"}]}
