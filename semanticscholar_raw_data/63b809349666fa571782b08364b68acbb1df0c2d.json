{"paperId": "63b809349666fa571782b08364b68acbb1df0c2d", "publicationVenue": {"id": "49699a88-4f79-403d-9250-6b3f361e5d7b", "name": "IEEE/ACM International Symposium on Code Generation and Optimization", "type": "conference", "alternate_names": ["CGO", "Symposium on Code Generation and Optimization", "IEEE/ACM Int Symp Code Gener Optim", "Symp Code Gener Optim"], "url": "http://www.cgo.org/"}, "title": "GraphIt to CUDA Compiler in 2021 LOC: A Case for High-Performance DSL Implementation via Staging with BuilDSL", "abstract": "Domain-Specific Languages (DSLs) provide the optimum balance between generalization and specialization that is crucial to getting the best performance for a particular domain. DSLs like Halide and GraphIt and their rich scheduling languages allow users to generate an implementation best suited for the algorithm and input. DSLs also provide the right abstraction for generating code for diverse architectures like GPUs, CPUs, and hardware accelerators. DSL compilers are massive, typically spanning tens of thousands of lines of code and need a frontend, some analysis and transformation passes, and target-specific code generation. These implementations usually require a great deal of compiler knowledge and domain experts cannot prototype DSLs without getting compiler experts involved.Using multi-stage programming in a high-level language like Scala, OCaml, or C++, is a great solution because it provides easy-to-use frontend and automatic code generation abilities. The DSL writers typically implement their abstraction as a library in the multi-stage programming language and use it to generate specialized code by providing partial inputs. This solves the problem only partially because DSLs like GraphIt have shown that several domain-specific analyses and transformations need to be performed to get the best performance. Special care has to be taken when targeting massively parallel architectures like GPUs where factors like load balancing, warp divergence, coalesced memory accesses play a critical role.In this paper, we demonstrate how to build an end-to-end DSL compiler framework and a graph DSL using multi-stage programming in C++. We show how the staged types can be extended to perform domain-specific data flow and control flow analyses and transformations. We also show how our generated CUDA code matches the performance of the code generated from the state-of-the-art graph DSL, GraphIt. We achieve all this in a very small fraction (8.4%) of the code size required to implement the traditional DSL compiler.", "venue": "IEEE/ACM International Symposium on Code Generation and Optimization", "year": 2022, "fieldsOfStudy": ["Computer Science"], "publicationTypes": ["Book", "JournalArticle"], "publicationDate": "2022-04-02", "journal": {"name": "2022 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)", "pages": "53-65"}, "authors": [{"authorId": "8871992", "name": "Ajay Brahmakshatriya"}, {"authorId": "2134745139", "name": "S. Amarasinghe"}], "citations": [{"paperId": "95637d34079d3c4ca5bd35c57e0dc1c46ce8c493", "title": "Flan: An Expressive and Efficient Datalog Compiler for Program Analysis"}, {"paperId": "2d8de1a3a6c1107ff848a8416ee7667af928fa6b", "title": "D2X: An eXtensible conteXtual Debugger for Modern DSLs"}]}
