{"paperId": "43e541514d82fa8606cf389d695906b7fc569f0a", "publicationVenue": {"id": "e76dcfc1-2df0-405b-8890-902005122cd0", "name": "Open Journal of Big Data", "type": "journal", "alternate_names": ["Open J Big Data"], "issn": "2365-029X", "url": "http://www.ronpub.com/index.php/journals/ojbd", "alternate_urls": ["https://www.ronpub.com/OJBD_2019v5i1n01_Marten.pdf"]}, "title": "Compile-Time Query Optimization for Big Data Analytics", "abstract": "Many emerging programming environments for large-scale data analysis, such as Map-Reduce, Spark, and Flink, provide Scala-based APIs that consist of powerful higher-order operations that ease the development of complex data analysis applications. However, despite the simplicity of these APIs, many programmers prefer to use declarative languages, such as Hive and Spark SQL, to code their distributed applications. Unfortunately, most current data analysis query languages are based on the relational model and cannot effectively capture the rich data types and computations required for complex data analysis applications. Furthermore, these query languages are not well-integrated with the host programming language, as they are based on an incompatible data model. To address these shortcomings, we introduce a new query language for data-intensive scalable computing that is deeply embedded in Scala, called DIQL, and a query optimization framework that optimizes and translates DIQL queries to byte code at compile-time. In contrast to other query languages, our query embedding eliminates impedance mismatch as any Scala code can be seamlessly mixed with SQL-like syntax, without having to add any special declaration. DIQL supports nested collections and hierarchical data and allows query nesting at any place in a query. With DIQL, programmers can express complex data analysis tasks, such as PageRank and matrix factorization, using SQL-like syntax exclusively. The DIQL query optimizer uses algebraic transformations to derive all possible joins in a query, including those hidden across deeply nested queries, thus unnesting nested queries of any form and any number of nesting levels. The optimizer also uses general transformations to push down predicates before joins and to prune unneeded data across operations. DIQL has been implemented on three Big Data platforms, Apache Spark, Apache Flink, and Twitter's Cascading/Scalding, and has been shown to have competitive performance relative to Spark DataFrames and Spark SQL for some complex queries. This paper extends our previous work on embedded data-intensive query languages by describing the complete details of the formal framework and the query translation and optimization processes, and by providing more experimental results that give further evidence of the performance of our system.", "venue": "Open Journal of Big Data", "year": 2019, "fieldsOfStudy": ["Computer Science"], "publicationTypes": ["JournalArticle"], "publicationDate": null, "journal": {"name": "Open J. Big Data", "pages": "35-61", "volume": "5"}, "authors": [{"authorId": "1746298", "name": "L. Fegaras"}], "citations": [{"paperId": "3309baa67df135d1eaa657f27a0525d1f5588876", "title": "A two-level formal model for Big Data processing programs"}, {"paperId": "fe1882b1367b6ebdbfc58f0837399a9e45f3ad55", "title": "An Abstract View of Big Data Processing Programs"}, {"paperId": "dc16e98518104a756add594fd7c3f1611bd0ffec", "title": "Modeling Big Data Processing Programs"}, {"paperId": "b4878bafddbdad4376fe76e4ecd2f9be5650130f", "title": "Scalable Querying of Nested Data"}, {"paperId": "37987beb153c7c7af196dc6d819cc269d5e28f87", "title": "Formal Methods: Foundations and Applications: 23rd Brazilian Symposium, SBMF 2020, Ouro Preto, Brazil, November 25\u201327, 2020, Proceedings"}]}
